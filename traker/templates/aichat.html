<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Expensy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for a cleaner look */
        #chat-window::-webkit-scrollbar {
            width: 6px;
        }
        #chat-window::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        #chat-window::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        #chat-window::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .message-bubble {
            max-width: 75%;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div id="chatbot-container" class="w-full h-screen bg-white shadow-xl flex flex-col">
        <!-- Header -->
        <div class="bg-blue-500 text-white p-4 flex items-center justify-between">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
            <h1 class="text-xl font-bold"> My Expensy Virtual Assistant</h1>
            <li><a href="/">Home</a></li>
            <button id="tts-toggle-btn" class="p-2 rounded-full hover:bg-blue-600 focus:outline-none">
                <!-- Speaker Icon -->
                <svg id="speaker-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                <!-- Mute Icon -->
                 <svg id="mute-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-x hidden"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line></svg>
            </button>
        </div>

        <!-- Chat Window -->
        <div id="chat-window" class="flex-1 p-4 overflow-y-auto bg-gray-50">
            <!-- Messages will be appended here -->
             <div class="flex justify-start mb-4">
                <div class="message-bubble bg-gray-200 text-gray-800 p-3 rounded-lg">
                    <p>hii, i am a ai chatbot "My Expensey" </p>
                </div>
            </div>
        </div>

        <!-- Loading Indicator -->
        <div id="loading-indicator" class="p-4 hidden">
             <div class="flex justify-start">
                <div class="message-bubble bg-gray-200 text-gray-800 p-3 rounded-lg">
                    <div class="flex items-center justify-center">
                        <div class="w-2 h-2 bg-gray-500 rounded-full animate-pulse mr-1"></div>
                        <div class="w-2 h-2 bg-gray-500 rounded-full animate-pulse mr-1" style="animation-delay: 0.2s;"></div>
                        <div class="w-2 h-2 bg-gray-500 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
                    </div>
                </div>
            </div>
        </div>


        <!-- Input Form -->
        <div class="p-4 bg-white border-t">
            <form id="chat-form" class="flex items-center">
                <input type="text" id="chat-input" class="flex-grow p-2 border-y border-l rounded-l-md focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Type or say something..." autocomplete="off">
                <button id="mic-btn" type="button" class="bg-gray-200 text-gray-600 px-4 py-2 border-y hover:bg-gray-300 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mic"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                </button>
                <button type="submit" class="bg-blue-500 text-white px-4 py-2 rounded-r-md hover:bg-blue-600 font-semibold">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </button>
            </form>
            <div id="quick-actions-container" class="mt-2 text-center hidden">
                <button id="local-plan-btn" class="bg-purple-500 text-white px-4 py-2 rounded-md hover:bg-purple-600 font-semibold transition-all duration-300 transform hover:scale-105">
                    {% comment %} ‚ú® Generate Local Preparedness Plan {% endcomment %}
                </button>
            </div>
        </div>
    </div>

    <script>
        const apiKeyContainer = document.getElementById('api-key-container');
        const chatbotContainer = document.getElementById('chatbot-container');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyButton = document.getElementById('save-api-key');
        const editApiKeyButton = document.getElementById('edit-api-key');

        const chatWindow = document.getElementById('chat-window');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const loadingIndicator = document.getElementById('loading-indicator');
        const quickActionsContainer = document.getElementById('quick-actions-container');
        const localPlanBtn = document.getElementById('local-plan-btn');
        const ttsToggleBtn = document.getElementById('tts-toggle-btn');
        const speakerIcon = document.getElementById('speaker-icon');
        const muteIcon = document.getElementById('mute-icon');
        const micBtn = document.getElementById('mic-btn');

        const GEMINI_MODEL = 'gemini-2.5-flash';
        let apiKey = 'AIzaSyAvCJp5iqw5a86pkyVl92n0xz1ByJwDeZE';
        let chatHistory = [];
        let lastUserLocation = null;
        let isTtsEnabled = true;

        // --- Text-to-Speech (TTS) ---
        function speak(text) {
            if (!isTtsEnabled || !window.speechSynthesis) return;
            // Clean up text for better speech synthesis
            const cleanedText = text.replace(/<[^>]*>/g, "").replace(/üö®|üî•|üåä|‚ú®/g, ''); 
            const utterance = new SpeechSynthesisUtterance(cleanedText);
            window.speechSynthesis.speak(utterance);
        }

        ttsToggleBtn.addEventListener('click', () => {
            isTtsEnabled = !isTtsEnabled;
            speakerIcon.classList.toggle('hidden');
            muteIcon.classList.toggle('hidden');
            if (!isTtsEnabled) {
                window.speechSynthesis.cancel(); // Stop any ongoing speech
            }
        });
        
   async function fetchExpenseData() {
    const response = await fetch("/api/expense-summary/");
    return await response.json();
}

        // --- Speech-to-Text (STT) ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            recognition.interimResults = false;

            micBtn.addEventListener('click', () => {
                micBtn.classList.add('bg-red-500', 'text-white');
                micBtn.classList.remove('bg-gray-200', 'text-gray-600');
                recognition.start();
            });

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                chatInput.value = transcript;
                chatForm.dispatchEvent(new Event('submit', { bubbles: true }));
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                addMessage('bot', `Sorry, I had a speech recognition error: ${event.error}`);
            };
            
            recognition.onend = () => {
                 micBtn.classList.remove('bg-red-500', 'text-white');
                 micBtn.classList.add('bg-gray-200', 'text-gray-600');
            };

        } else {
            micBtn.style.display = 'none'; // Hide mic button if not supported
            console.warn('Speech Recognition API is not supported in this browser.');
        }


        // Function to scroll to the bottom of the chat window
        function scrollToBottom() {
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        // Function to add a message to the chat window
        function addMessage(sender, message) {
            const messageElement = document.createElement('div');
            messageElement.className = `flex mb-4 ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
            
            const bubble = document.createElement('div');
            bubble.className = `message-bubble p-3 rounded-lg ${sender === 'user' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'}`;
            bubble.innerHTML = `<p>${message.replace(/\n/g, '<br>')}</p>`; // Use innerHTML to render formatted text
            
            messageElement.appendChild(bubble);
            chatWindow.appendChild(messageElement);

            if (sender === 'bot') {
                speak(message);
            }

            scrollToBottom();
        }

        // Handle form submission
        // ----------------- Robust submit handler (REPLACE your existing one) -----------------
chatForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    // fetch expense data first
    let expenseData;
    try {
        expenseData = await fetchExpenseData();
        console.log("Expense data fetched:", expenseData);
    } catch (err) {
        console.error("Failed to fetch expense data:", err);
        addMessage('bot', '‚ö†Ô∏è Error fetching your expense data. Check the backend endpoint /api/expense-data/.');
        return;
    }

    const userInput = chatInput.value.trim();
    if (!userInput) return;

    addMessage('user', userInput);
    chatInput.value = '';
    loadingIndicator.classList.remove('hidden');
    quickActionsContainer.classList.add('hidden');
    scrollToBottom();

    // store location if present
    const locationKeywords = ['in ', 'at ', 'my location is', 'i am in'];
    if (locationKeywords.some(keyword => userInput.toLowerCase().includes(keyword))) {
        lastUserLocation = userInput;
    }

    // push to chat history (keeps previous UI behaviour)
    chatHistory.push({ role: "user", parts: [{ text: userInput }] });

    try {
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;

        // build a final prompt (shorten if too large)
        const dataString = `
Total Credit: ${expenseData.total_credit}
Total Debit: ${expenseData.total_debit}
Category Summary: ${JSON.stringify(expenseData.category_summary)}
Recent 10 Transactions: ${JSON.stringify(expenseData.recent_transactions)}
`;

        if (dataString.length > 180000) { // large threshold ‚Äî adjust as needed
            console.warn("Expense data payload is very large (" + Math.round(dataString.length/1024) + " KB). Consider sending summarized data or using a server-side proxy to call the LLM.");
        }

        const finalPrompt = `
You are my personal Expense Advisor AI.
I am giving my FULL expense database (balance + transactions).
Analyze it deeply and give me financial insights.

IMPORTANT:
Do NOT output raw JSON.

Here is my expense data:
${dataString}

User Query:
${userInput}
`.trim();

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [{ text: finalPrompt }]
                }
            ],
            systemInstruction: {
                parts: [
                    { text: `
You are a Financial Expense Advisor AI.
Analyze credits & debits, find overspending, compute balance, detect patterns, and provide clear advice.
NEVER output raw JSON. Format the response in headings and bullet points.
`.trim() }
                ]
            }
        };

        // debug logs to inspect what's being sent
        console.log("Calling Gemini API:", apiUrl);
        console.log("Payload size (chars):", JSON.stringify(payload).length);
        // console.log("Payload:", payload); // uncomment if you want to inspect full payload (be careful with API key)

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        // show HTTP status in console for debugging
        console.log("API response status:", response.status);

        // if server responded with HTTP error, show full text
        if (!response.ok) {
            const text = await response.text();
            console.error("API returned non-OK status. Body:", text);
            addMessage('bot', `‚ö†Ô∏è API Error (${response.status}): ${text.substring(0, 300)}`); // short preview
            return;
        }

        // try to parse JSON
        const result = await response.json();
        console.log("API result:", result);

        // Robust extraction of message text with fallbacks
        let botMessage = null;
        try {
            // common shape: candidates[0].content.parts[0].text
            botMessage = result?.candidates?.[0]?.content?.parts?.[0]?.text;
        } catch (err) { /* ignore */ }

        if (!botMessage) {
            // other possible shapes: outputs[0].content[0].text or outputText
            botMessage = result?.outputText || result?.candidates?.[0]?.text ||
                         (result?.candidates?.[0]?.content?.parts?.map(p => p?.text).join("\n")) ||
                         (result?.outputs?.[0]?.content?.map(c => c?.text).join("\n"));
        }

        if (botMessage) {
            chatHistory.push({ role: "model", parts: [{ text: botMessage }] });
            addMessage('bot', botMessage);
            if (lastUserLocation) quickActionsContainer.classList.remove('hidden');
        } else {
            console.error("Could not find bot message in response. Full result:", result);
            addMessage('bot', "‚ö†Ô∏è I couldn't parse the model's response. Check console for details.");
        }

    } catch (error) {
        console.error("Error calling Gemini API:", error);
        addMessage('bot', `Error: ${error.message || error}`);
    } finally {
        loadingIndicator.classList.add('hidden');
        scrollToBottom();
    }
});


        // Event listener for the new Gemini-powered feature
        localPlanBtn.addEventListener('click', async () => {
             if (!lastUserLocation) return;

            quickActionsContainer.classList.add('hidden');
            loadingIndicator.classList.remove('hidden');
            scrollToBottom();

            const planPrompt = `Based on the user's previously mentioned location context ("${lastUserLocation}"), generate a concise and actionable disaster preparedness plan. Focus on the most likely local disasters for that area. The plan should include a checklist of essential supplies and key local emergency contact numbers. Format the response clearly with headings and bullet points.`;

            try {
                 const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;
                
                // We use a temporary history for this specific call to not pollute the main chat flow
                const payload = {
                    contents: [{ role: "user", parts: [{ text: planPrompt }] }],
                     systemInstruction: {
                        parts: [{
                            text: "You are an intelligent Expense Tracker assistant.Your role is to help users manage their personal finances by: Recording new transactions with clear descriptions, amounts, and type (income or expense).- Automatically updating the current balance after each transaction.- Categorizing transactions (e.g., food, travel, bills, salary) for better insights.- Generating summaries: daily, weekly, monthly totals of income and expenses.- Highlighting unusual spending patterns or overspending alerts.- Providing simple, actionable insights like ‚ÄúYour food expenses increased 20% compared to last month.‚Äù- Always respond clearly, concisely, and in a user-friendly tone."
                        }]
                    },
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error.message || 'An API error occurred.');
                }

                const result = await response.json();
                const planMessage = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (planMessage) {
                    // We add this special response to the chat history as well
                    chatHistory.push({ role: "user", parts: [{ text: "Generate Local Preparedness Plan" }] });
                    chatHistory.push({ role: "model", parts: [{ text: planMessage }] });
                    addMessage('bot', planMessage);
                } else {
                    addMessage('bot', "Sorry, I couldn't generate the plan. Please try again.");
                }

            } catch (error) {
                 addMessage('bot', `Error generating plan: ${error.message}`);
                console.error('Error in local plan generation:', error);
            } finally {
                loadingIndicator.classList.add('hidden');
                scrollToBottom();
                lastUserLocation = null; // Reset location after use
            }

        });
    </script>
</body>
</html>